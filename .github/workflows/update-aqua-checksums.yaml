---
# yamllint disable rule:line-length
name: update-aqua-checksums

on:
  workflow_call:
    inputs:
      aqua_dirs:
        required: true
        type: string
      git_ref:
        required: true
        type: string
      mise_ignore_cfg:
        required: false
        type: string
        default: ""
      mise_log_level:
        required: false
        type: string
        default: "info"
      prune:
        required: false
        type: boolean
        default: true
      semantic_commit_type:
        required: false
        type: string
        default: "chore"
      semantic_commit_scope:
        required: false
        type: string
        default: "dev-tools"
    secrets:
      app_id:
        required: true
      app_private_key:
        required: true

env:
  MISE_IGNORED_CONFIG_PATHS: ${{ inputs.mise_ignore_cfg != '' && format('{0}/current/{1}', github.workspace, inputs.mise_ignore_cfg) || '' }}

jobs:
  update-aqua-checksums:
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
    - name: Generate github app token
      uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2
      id: app-token
      with:
        app-id: ${{ secrets.app_id }}
        private-key: ${{ secrets.app_private_key }}
        owner: ${{ github.repository_owner }}

    - name: Checkout tools
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      with:
        fetch-depth: 1
        path: tools
        repository: ppat/github-workflows
        persist-credentials: false

    - name: Checkout current
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      with:
        path: current
        repository: ${{ github.repository }}
        ref: ${{ inputs.git_ref }}
        persist-credentials: true
        fetch-depth: 0
        token: ${{ steps.app-token.outputs.token }}

    - name: Cache mise
      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4
      with:
        path: ~/.local/share/mise
        key: mise-${{hashFiles('tools/mise.toml')}}-${{hashFiles('current/mise.toml')}}
        restore-keys: |
          mise-${{hashFiles('tools/mise.toml')}}
          mise-

    - name: Setup default mise configuration
      # yamllint disable-line rule:indentation
      run: |
        mkdir -p ~/.config/mise
        ln -s $GITHUB_WORKSPACE/tools/mise.toml ~/.config/mise/config.toml

    - name: Setup mise
      uses: jdx/mise-action@c37c93293d6b742fc901e1406b8f764f6fb19dac # v2.4.4
      env:
        MISE_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # renovate: datasource=github-releases depName=jdx/mise
        version: "v2025.7.32"
        install: true
        cache: false
        experimental: true
        log_level: ${{ inputs.mise_log_level }}
        working_directory: ${{ github.workspace }}/current

    - name: Update aqua-checksums.json
      env:
        AQUA_DIRS: ${{ inputs.aqua_dirs }}
        AQUA_GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        PRUNE: "${{ inputs.prune == 'true' && '-prune' || '' }}"
      shell: bash
      working-directory: ./current
      # yamllint disable-line rule:indentation
      run: |
        DIR_LIST=$(mktemp)
        if [[ "${AQUA_DIRS}" == "ALL" ]]; then
           find . -type f -name aqua.yaml -exec dirname {} \; | sort | uniq > ${DIR_LIST}
        else
          echo ${AQUA_DIRS} | tr ' ' '\n' > ${DIR_LIST}
        fi

        echo "Updating checksums..."
        while IFS= read -r dir; do
          echo "${dir}"
          pushd "${dir}" > /dev/null 2>&1
          aqua update-checksum ${PRUNE} 2>&1 | pr -t -o 4
          popd > /dev/null 2>&1
          echo
        done < ${DIR_LIST} | pr -t -o 4

    - name: Commit and push updated checksums
      env:
        BRANCH: ${{ inputs.git_ref }}
        GH_TOKEN: ${{ steps.app-token.outputs.token }}
        MSG: "${{ inputs.semantic_commit_type }}(${{ inputs.semantic_commit_scope }}): update aqua checksums"
        REPO: ${{ github.repository }}
      shell: bash
      working-directory: ./current
      # yamllint disable-line rule:indentation
      run: |
        set -euo pipefail
        git add -A
        # 1) Collect changes
        mapfile -t add_or_mod < <(git status --porcelain | awk '/^[AM] /{print $2}')
        mapfile -t deleted    < <(git status --porcelain | awk '/^ D /{print $2}')

        if [[ ${#add_or_mod[@]} -eq 0 && ${#deleted[@]} -eq 0 ]]; then
          echo "No changes to commit."
          exit 0
        fi

        # 2) Build additions array: [{path, contents(base64)}...]
        additions_json="[]"
        for f in "${add_or_mod[@]}"; do
          # Base64 RFC 4648 (GNU coreutils: -w 0 = single line)
          b64=$(base64 -w 0 "$f")
          additions_json=$(jq -c --arg p "$f" --arg c "$b64" \
            '. + [{path:$p, contents:$c}]' <<<"$additions_json")
        done

        # 3) Build deletions array: [{path}...]
        deletions_json="[]"
        for f in "${deleted[@]}"; do
          deletions_json=$(jq -c --arg p "$f" '. + [{path:$p}]' <<<"$deletions_json")
        done

        # 4) Resolve expectedHeadOid for optimistic concurrency
        head_oid=$(
          gh api graphql -f query='
            query($repo:String!, $qref:String!) {
              repository(nameWithOwner:$repo) {
                ref(qualifiedName:$qref) { target { ... on Commit { oid } } }
              }
            }' \
            -f repo="$REPO" -f qref="refs/heads/$BRANCH" \
            --jq '.data.repository.ref.target.oid'
        )

        # 5) Create single verified commit
        vars=$(jq -c --null-input \
          --arg repo "$REPO" \
          --arg branch "$BRANCH" \
          --arg msg "$MSG" \
          --arg head "$head_oid" \
          --argjson adds "$additions_json" \
          --argjson dels "$deletions_json" \
          '{ repo: $repo, branch: $branch, msg: $msg, head: $head,
             additions: $adds, deletions: $dels }')

        read -r -d '' GQL <<'EOF'
        mutation($repo:String!, $branch:String!, $msg:String!,
                 $head:GitObjectID!, $additions:[FileAddition!]!, $deletions:[FileDeletion!]!) {
          createCommitOnBranch(input:{
            branch:{ repositoryNameWithOwner:$repo, branchName:$branch },
            message:{ headline:$msg },
            expectedHeadOid:$head,
            fileChanges:{ additions:$additions, deletions:$deletions }
          }) {
            commit { oid url }
          }
        }
        EOF

        gh api graphql -f query="$GQL" -f variables="$vars" --jq '.data.createCommitOnBranch.commit' | jq

        # exit w/ error code as the push should trigger another run of this workflow (which should result in no further commits)
        exit 1
