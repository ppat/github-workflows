---
# yamllint disable rule:line-length
name: update-aqua-checksums

on:
  workflow_call:
    inputs:
      aqua_dirs:
        required: true
        type: string
      git_ref:
        required: true
        type: string
      mise_ignore_cfg:
        required: false
        type: string
        default: ""
      mise_log_level:
        required: false
        type: string
        default: "info"
      prune:
        required: false
        type: boolean
        default: true
      semantic_commit_type:
        required: false
        type: string
        default: "chore"
      semantic_commit_scope:
        required: false
        type: string
        default: "dev-tools"
    secrets:
      app_id:
        required: true
      app_private_key:
        required: true

env:
  MISE_IGNORED_CONFIG_PATHS: ${{ inputs.mise_ignore_cfg != '' && format('{0}/current/{1}', github.workspace, inputs.mise_ignore_cfg) || '' }}

jobs:
  update-aqua-checksums:
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
    - name: Generate github app token
      uses: actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e # v2
      id: app-token
      with:
        app-id: ${{ secrets.app_id }}
        private-key: ${{ secrets.app_private_key }}
        owner: ${{ github.repository_owner }}

    - name: Checkout tools
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      with:
        fetch-depth: 1
        path: tools
        repository: ppat/github-workflows
        persist-credentials: false

    - name: Checkout current
      uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
      with:
        path: current
        repository: ${{ github.repository }}
        ref: ${{ inputs.git_ref }}
        persist-credentials: true
        fetch-depth: 0
        token: ${{ steps.app-token.outputs.token }}

    - name: Cache mise
      uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4
      with:
        path: ~/.local/share/mise
        key: mise-${{hashFiles('tools/mise.toml')}}-${{hashFiles('current/mise.toml')}}
        restore-keys: |
          mise-${{hashFiles('tools/mise.toml')}}
          mise-

    - name: Setup default mise configuration
      # yamllint disable-line rule:indentation
      run: |
        mkdir -p ~/.config/mise
        ln -s $GITHUB_WORKSPACE/tools/mise.toml ~/.config/mise/config.toml

    - name: Setup mise
      uses: jdx/mise-action@c37c93293d6b742fc901e1406b8f764f6fb19dac # v2.4.4
      env:
        MISE_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        # renovate: datasource=github-releases depName=jdx/mise
        version: "v2025.7.32"
        install: true
        cache: false
        experimental: true
        log_level: ${{ inputs.mise_log_level }}
        working_directory: ${{ github.workspace }}/current

    - name: Update aqua-checksums.json
      env:
        AQUA_DIRS: ${{ inputs.aqua_dirs }}
        AQUA_GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        PRUNE: "${{ inputs.prune == 'true' && '-prune' || '' }}"
      shell: bash
      working-directory: ./current
      # yamllint disable-line rule:indentation
      run: |
        DIR_LIST=$(mktemp)
        if [[ "${AQUA_DIRS}" == "ALL" ]]; then
           find . -type f -name aqua.yaml -exec dirname {} \; | sort | uniq > ${DIR_LIST}
        else
          echo ${AQUA_DIRS} | tr ' ' '\n' > ${DIR_LIST}
        fi

        echo "Updating checksums..."
        while IFS= read -r dir; do
          echo "${dir}"
          pushd "${dir}" > /dev/null 2>&1
          aqua update-checksum ${PRUNE} 2>&1 | pr -t -o 4
          popd > /dev/null 2>&1
          echo
        done < ${DIR_LIST} | pr -t -o 4

    - name: Commit and push updated checksums
      env:
        BRANCH: ${{ inputs.git_ref }}
        GH_TOKEN: ${{ steps.app-token.outputs.token }}
        MSG: "${{ inputs.semantic_commit_type }}(${{ inputs.semantic_commit_scope }}): update aqua checksums"
        REPO: ${{ github.repository }}
      shell: bash
      working-directory: ./current
      # yamllint disable-line rule:indentation
      run: |
        set -euo pipefail
        set -x
        command -v jq >/dev/null || (sudo apt-get update && sudo apt-get install -y jq)

        # 0) Stage everything
        git add -A

        # 1) Collect staged changes (handles spaces via -z)
        mapfile -d '' status < <(git diff --cached --name-status -z)

        additions_json='[]'
        deletions_json='[]'

        i=0
        while (( i < ${#status[@]} )); do
          code="${status[$i]}"; (( ++i ))
          case "$code" in
            A|M)
              path="${status[$i]}"; (( ++i ))
              b64=$(base64 -w 0 -- "$path")
              additions_json=$(jq -c --arg p "$path" --arg c "$b64" \
                '. + [{path:$p, contents:$c}]' <<<"$additions_json")
              ;;
            D)
              path="${status[$i]}"; (( ++i ))
              deletions_json=$(jq -c --arg p "$path" '. + [{path:$p}]' <<<"$deletions_json")
              ;;
            R*)
              old="${status[$i]}"; (( ++i ))
              new="${status[$i]}"; (( ++i ))
              deletions_json=$(jq -c --arg p "$old" '. + [{path:$p}]' <<<"$deletions_json")
              b64=$(base64 -w 0 -- "$new")
              additions_json=$(jq -c --arg p "$new" --arg c "$b64" \
                '. + [{path:$p, contents:$c}]' <<<"$additions_json")
              ;;
            *)
              path="${status[$i]}"; (( ++i ))
              echo "Skipping change type '$code' for '$path'"
              ;;
          esac
        done

        if [[ "$(jq 'length' <<<"$additions_json")" -eq 0 && "$(jq 'length' <<<"$deletions_json")" -eq 0 ]]; then
          echo "No staged changes; nothing to commit."
          exit 0
        fi

        # 2) Resolve expectedHeadOid
        OWNER="${REPO%%/*}"
        NAME="${REPO#*/}"
        head_oid=$(
          gh api graphql \
            -f query='
              query($owner:String!, $name:String!, $qref:String!) {
                repository(owner:$owner, name:$name) {
                  ref(qualifiedName:$qref) { target { __typename ... on Commit { oid } } }
                }
              }' \
            -f owner="$OWNER" -f name="$NAME" -f qref="refs/heads/$BRANCH" \
            --jq '.data.repository.ref.target.oid' \
          || true
        )
        if [[ -z "${head_oid:-}" || "${head_oid}" == "null" ]]; then
          echo "ERROR: could not resolve expectedHeadOid for refs/heads/$BRANCH"
          gh api graphql -f query='query($o:String!,$n:String!,$r:String!){
            repository(owner:$o,name:$n){ ref(qualifiedName:$r){ target{ __typename } } }
          }' -f o="$OWNER" -f n="$NAME" -f r="refs/heads/$BRANCH" || true
          exit 1
        fi

        # 3) Create a single verified commit
        vars=$(jq -c --null-input \
          --arg repo "$REPO" \
          --arg branch "$BRANCH" \
          --arg msg "$MSG" \
          --arg head "$head_oid" \
          --argjson adds "$additions_json" \
          --argjson dels "$deletions_json" \
          '{ input:{
              branch:{ repositoryNameWithOwner:$repo, branchName:$branch },
              message:{ headline:$msg },
              expectedHeadOid:$head,
              fileChanges:{ additions:$adds, deletions:$dels }
            }}')

        read -r -d '' GQL <<'EOF'
        mutation($input: CreateCommitOnBranchInput!) {
          createCommitOnBranch(input:$input) {
            commit { oid url }
          }
        }
        EOF

        if ! out=$(gh api graphql -f query="$GQL" -f variables="$vars" --jq '.data.createCommitOnBranch.commit' 2>err.log); then
          echo "GraphQL commit failed:"
          cat err.log
          echo "Variables (redacted contents):"
          jq '(.input.fileChanges.additions[]?.contents)="<base64-redacted>"' <<<"$vars"
          exit 1
        fi
        echo "$out" | jq

        # exit w/ error code as the push should trigger another run of this workflow (which should result in no further commits)
        exit 1
